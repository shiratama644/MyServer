-   **URL:** `shiratama.mydns.jp/admin/`
-   **コンテナ:** `LXC 107`
-   **コンセプト:** Proxmox VE上で稼働する全サービスを、単一のWebインターフェースから統合的に監視・管理するための管理者専用ダッシュボード。SSHによるコマンドライン操作を極力不要にし、直感的かつ迅速なサーバー運用を実現することを目的とする。
-   **構成:** **一体型 (Next.js + Express.js + Socket.IO)**

---

### 1. ユーザー権限と認証

-   **認証方式:** **Googleアカウント + 固定パスワードによる2段階認証。**
    1.  **第1段階 (Google認証):** `NextAuth.js`ライブラリのGoogle Providerを利用。環境変数に設定された特定のGoogleアカウント以外はアクセスを拒否する。
    2.  **第2段階 (パスワード認証):** Google認証成功後、パスワード入力画面に遷移。環境変数に設定されたサイト専用の固定パスワードを入力する。
-   **権限レベル (Role):**
    1.  **ADMIN (管理者):** サイトの全機能にアクセス可能。
    2.  **GUEST (未認証):** ログインページのみ表示。
-   **認証情報の設定フロー:**
    -   `.env`ファイルに、許可するGoogleアカウントのメールアドレスと、サイト専用パスワードを設定する。
        -   `ADMIN_GOOGLE_EMAILS=2011hikaru.a@gmail.com`
        -   `ADMIN_SITE_PASSWORD=")I4)@PE0AW,ZHHp^{<^4"`
    -   アプリケーションは起動時にこの設定を読み込み、認証ロジックで使用する。

---

### 2. UI/UX

-   **デザイン:**
    -   **テーマ:** ダークテーマを基調とした、視認性の高いデザイン。サーバー情報を扱うため、グラフやステータス表示には明確な配色（緑: 正常, 黄: 注意, 赤: 異常）を用いる。
    -   **レスポンシブ:** PCでの操作を主眼に置くが、スマートフォンからも緊急時の基本的な状態確認や再起動操作ができるように最適化する。
-   **ページ構成:**
    -   **ナビゲーション:** PCでは画面左側に、各機能へのリンクを持つ固定サイドバーを配置。
    -   **ログインページ (`/admin/g-login`):** 1段階目の認証 **(google)** となるページ。
    -   **2段階ログインページ (`/admin/two-login`):** 2段階目の認証 **(password)** となるページ。
    -   **ダッシュボード (`/admin/dashboard`):** ログイン後の初期表示ページ。サーバー全体の健全性をひと目で確認できる。
    -   **ゲスト管理 (`/admin/guests`):** LXC/KVMの一覧表示と基本操作を行う。
    -   **アプリケーション管理 (`/admin/apps`):** 最初に操作したいLXC/KVMを選択し、その中のPM2で管理されるNode.jsアプリを選択して操作を行う。
    -   **ログビューア (`/admin/logs`):** 各種ログファイルを確認する。
    -   **リモートターミナル (`/admin/terminal`):** サーバーのシェルを直接操作する。
    -    **セキュリティ (`/admin/security`):** サーバーへの不正アクセス試行や、システムの脆弱性を監視し、セキュリティ状態を直感的に把握する。

---

### 3. 主要機能

#### 3.1 ログイン

-   **UI - 1段階目 (`/admin/g-login`):**
    -   画面中央に「Googleアカウントでログイン」ボタンを配置。
    -   背景にはThree.jsで作成したモダンでインタラクティブな3Dグラフィックスを表示する。
-   **UI - 2段階目 (`/admin/two-login`):**
    -   画面中央にパスワード入力フィールドと「認証」ボタンを配置。
    -   背景は1段階目と同様の3Dグラフィックスを維持する。
-   **機能:**
    -   **Google認証 (1段階目):**
        -   「Googleアカウントでログイン」ボタンをクリックすると、Googleの認証画面にリダイレクトされる。
        -   ログインに成功したGoogleアカウントのメールアドレスが、サーバーの環境変数 `ADMIN_GOOGLE_EMAILS` に設定されたものと一致するかを検証する。
        -   **一致した場合:** 認証成功のセッションを一時的に保持し、2段階目のパスワード入力ページ (`/admin/two-login`) へ自動的にリダイレクトする。
        -   **一致しない場合:** エラーメッセージを表示し、ログインプロセスを中断する。このログイン失敗イベントは、IPアドレス等の情報と共に`audit_logs`テーブルに記録される。
    -   **パスワード認証 (2段階目):**
        -   ユーザーがパスワードを入力し、「認証」ボタンをクリックすると、入力されたパスワードがサーバーへ送信される。
        -   サーバーは、送信されたパスワードと環境変数 `ADMIN_SITE_PASSWORD` の値を照合する。
        -   **一致した場合:** 最終的なログイン成功とみなし、管理者サイトのメインページ（ダッシュボード）へのアクセスを許可する完全な認証セッションを確立する。この成功イベントも`audit_logs`テーブルに記録される。
        -   **一致しない場合:** エラーメッセージ（例:「パスワードが違います」）を表示する。ログイン失敗イベントは`audit_logs`テーブルに記録される。セキュリティのため、複数回失敗した場合は一時的に同IPからの試行をロックするなどの対策も考慮する。
#### 3.2 ダッシュボード

-   **UI:** 複数の情報カードがグリッド状に配置されたレイアウト。
-   **機能:**
    -   **ホストリソース監視:**
        -   CPU使用率、メモリ使用率、ネットワークトラフィックをリアルタイムで更新される折れ線グラフで表示。
        -   SSDストレージ使用率をゲージ形式で表示。
    -   **ゲストサマリー:**
        -   全ゲストの総数と、現在「起動中」のゲスト数を表示。

#### 3.3 ゲスト管理

-   **UI:** テーブル（表）形式で全ゲストの一覧を表示。
-   **表示項目:** ID, 名前, 種別(LXC/KVM), ステータス(起動中/停止中), IPアドレス, CPU使用率, メモリ使用率。
-   **機能:**
    -   **状態表示:** 「起動中」は緑色、「停止中」は灰色のラベルで表示し、視覚的に分かりやすくする。
    -   **操作:** 各行の右端にアクションボタン（「起動」「停止」「再起動」）を配置。クリックすると確認ダイアログが表示され、承認するとサーバーサイドにリクエストが送信される。

#### 3.4 アプリケーション管理

-   **UI:** ページ上部に操作対象のLXCコンテナを選択するドロップダウンリストを配置。その下に、選択されたコンテナ内のPM2プロセスがテーブル形式で表示される。
-   **表示項目:** アプリ名, ID, ステータス, CPU使用率, メモリ使用量, uptime。
-   **機能:**
    -   **コンテナ選択:** ドロップダウンでLXCコンテナを選択すると、そのコンテナ内のPM2プロセス情報が非同期で読み込まれ、一覧が更新される。
    -   **プロセス操作:** 各プロセス行に「再起動」「停止」ボタンを配置。
    -   **ログ表示:** 「ログ表示」ボタンをクリックすると、画面下部またはモーダルウィンドウが開き、該当プロセスのリアルタイムログ（標準出力/エラー出力）が表示される。

#### 3.5 ログビューア

-   **UI:** ページ上部に閲覧したいログファイルを選択するドロップダウンリストと、「リアルタイム追跡」のON/OFFを切り替えるスイッチを配置。ログ内容は大きなテキストエリアに表示される。
-   **対象ログ:**
    -   DDNS自動更新ログ (`mydns_update.log`)
    -   Nginxアクセスログ (`access.log`)
    -   Nginxエラーログ (`error.log`)
-   **機能:**
    -   **ログ選択:** ドロップダウンでログを選択すると、サーバーから最新のログ内容（例: 末尾100行）が読み込まれる。
    -   **リアルタイム追跡:** スイッチをONにすると、WebSocketを通じてサーバーからのログ追記情報がリアルタイムにフロントエンドに送られ、テキストエリアの末尾に自動で追加されていく。

#### 3.6 リモートターミナル

-   **UI:** ページ上部に接続先のホスト/コンテナを選択するドロップダウンリストを配置。その下に、黒い背景のターミナル画面が表示される。
-   **機能:**
    -   **接続先選択:** ドロップダウンで接続先（Proxmoxホスト, LXC 107など）を選択すると、サーバーサイドで対応するターミナルプロセスが起動し、WebSocketで接続される。
    -   **ターミナル操作:** ユーザーが入力したキーボード操作はWebSocket経由でサーバーのターミナルプロセスに送られ、その実行結果（画面出力）が同じくWebSocket経由でフロントエンドに返され、画面に描画される。

#### 3.7 セキュリティ

-   **UI:** ページ全体は「アクセスログ」「ファイアウォール」「パッケージ更新」の3つのタブで構成される。各タブには、関連する情報を表示するためのテーブルやカード、操作を行うためのボタンや入力フォームが配置される。
-   **機能:**
    -   **アクセスログ:**
        -   管理者サイトへの全ログイン試行履歴を`audit_logs`テーブルから取得し、一覧表示する。
        -   ログイン失敗の履歴は赤くハイライトされ、管理者に注意を促す。
        -   一覧のIPアドレスをクリックすると、外部のIP情報サイトで詳細を確認できる。
        -   ログインに失敗したIPアドレスの横には、ワンクリックでファイアウォールに追加するための「このIPをブロック」ボタンが表示される。
    -   **ファイアウォール:**
        -   現在のUFW（Uncomplicated Firewall）の稼働状態（有効/無効）を表示する。
        -   `firewall_blocks`テーブルから現在ブロック中のIPアドレス一覧を取得し、ブロック理由のメモと共に表示する。
        -   入力フォームにIPアドレスとメモを入力し、新しいブロックルールを追加できる。この操作はDBに記録されると同時に、サーバーの`ufw`コマンドを実行する。
        -   一覧の「解除」ボタンを押すことで、対象IPアドレスのブロックを解除できる。この操作もDBの状態を更新し、`ufw`コマンドを実行する。
    -   **パッケージ更新:**
        -   ドロップダウンリストから確認したい対象（Proxmoxホストまたは各LXCコンテナ）を選択する。
        -   選択された対象に対し、サーバーサイドで`apt`コマンドを実行し、更新可能なパッケージの一覧（特にセキュリティアップデート）を取得して表示する。
        -   「最新情報を取得」ボタンで、パッケージリストを最新の状態に更新できる。
        -   「一括アップグレード」ボタンを押すと、警告ダイアログの承認後、対象システムの全パッケージを更新する。実行中のログはリアルタイムで画面に表示される。

---

### 4. サーバーサイド処理

このサイトのバックエンドは、フロントエンドからの要求に応じてサーバーの情報を取得・操作し、その結果をリアルタイムに返す役割を担います。データベース(`admin_db`)と連携し、状態の永続化も行います。

#### **認証 (Auth)**

-   **概要:** `NextAuth.js`とカスタムAPIを組み合わせ、Google認証とパスワード認証による厳格な2段階認証プロセスを実装します。すべての認証試行は`audit_logs`テーブルに記録されます。
-   **処理フロー:**
    1.  **Google認証 (第1段階):**
        -   フロントエンドから`signIn('google')`が呼び出されると、`NextAuth.js`がGoogleとのOAuthフローを処理します。
        -   `callbacks`の`signIn`関数内で、返されたユーザープロフィールのメールアドレスが環境変数`ADMIN_GOOGLE_EMAILS`に記載されているか検証します。
        -   **検証成功時:** `NextAuth.js`はセッションを発行しますが、このセッションには「第1段階認証済み」を示す一時的なフラグを設定します。同時に、`audit_logs`に成功レコードをINSERTします。
        -   **検証失敗時:** `signIn`コールバックで`false`を返し、認証を中断させます。`audit_logs`に失敗レコードをINSERTします。
    2.  **パスワード認証 (第2段階):**
        -   フロントエンドは、「第1段階認証済み」のセッションを持つユーザーのみがアクセスできるパスワード入力ページを表示します。
        -   入力されたパスワードは、専用のAPIエンドポイント（例: `POST /api/auth/verify-password`）に送信されます。
        -   APIは、受け取ったパスワードと環境変数`ADMIN_SITE_PASSWORD`を安全な方法（ハッシュ化された値との比較が望ましいが、仕様上は直接比較）で照合します。
        -   **照合成功時:** `NextAuth.js`のセッションを更新し、「完全認証済み」のフラグを立てます。これにより、サイトの全機能へのアクセスが許可されます。`audit_logs`に成功レコードをINSERTします。
        -   **照合失敗時:** エラーを返し、`audit_logs`に失敗レコードをINSERTします。

#### **リアルタイム通信 (WebSocket)**

-   **概要:** `Socket.IO`を利用して、クライアントとサーバー間の双方向リアルタイム通信を確立します。認証済みのユーザーのみがWebSocketサーバーに接続できるよう、接続時にセッショントークンを検証します。
-   **通信チャンネル（イベント）:**
    -   `get:host_stats`: サーバーは`os-utils`や`systeminformation`などのライブラリを使用し、ProxmoxホストのCPU使用率、メモリ使用率、ネットワークトラフィックを1秒ごとに取得します。取得したデータは整形され、接続している全クライアントにブロードキャストされます。
    -   `stream:logs`: クライアントからログファイルの指定を受けると、サーバーは`tail`コマンドを子プロセスとして起動（`spawn`）します。ログファイルに追記があるたびに、その内容をWebSocket経由でクライアントに送信します。クライアントが切断するか、追跡を停止した場合、子プロセスは適切に終了させます。
    -   `terminal:io`: リモートターミナルセッションの双方向通信を中継します。（詳細は「リモートターミナル」の項で後述）

#### **サーバー・ゲスト操作**

-   **概要:** フロントエンドからのHTTPリクエスト（APIコール）に応じて、サーバー上でProxmox VEの管理コマンドや`pm2`コマンドを実行します。すべての操作は、コマンドインジェクション対策を施した上で安全に実行されます。
-   **技術:**
    -   Node.jsの`child_process.execFile`または`spawn`を利用します。`exec`と異なり、引数を配列で渡せるため、インジェクションのリスクを低減できます。
-   **処理例 (ゲスト管理):**
    -   **一覧取得 (`GET /api/guests`):** `pct list --output-format=json`や`qm list --output-format=json`コマンドを実行します。Proxmoxが直接JSONを出力するため、手動でのパースが不要になり、安全かつ効率的にデータを取得できます。
    -   **操作実行 (`POST /api/guests/:id/reboot`):** リクエストから受け取ったゲストID（例: `101`）が**数値であること**を厳格に検証します。検証後、`pct`または`qm`を判断し、`execFile('pct', ['reboot', guestId])`のようにコマンドを実行します。コマンドの終了コードを確認し、成功または失敗のステータスをフロントエンドに返します。
    -   **アプリケーション管理 (`GET /api/apps/:guestId`):** `pct exec <guestId> -- pm2 jlist` を実行し、コンテナ内のPM2プロセス情報をJSON形式で取得します。

#### **リモートターミナル (node-pty)**

-   **概要:** `node-pty`ライブラリを利用して、WebSocketを介した本格的な擬似ターミナル環境を提供します。
-   **処理フロー:**
    1.  クライアントがWebSocket経由でターミナルセッションの開始を要求すると、サーバーは`node-pty`の`spawn`関数を呼び出して、指定された接続先（Proxmoxホストなら`/bin/bash`、LXCなら`pct enter <id>`）のシェルプロセスを起動します。
    2.  WebSocketの`message`イベントと、`node-pty`プロセスの`data`イベントを相互にリッスンします。
    3.  クライアントからのメッセージ（キー入力など）は`node-pty`プロセスの`write`メソッドに渡し、シェルの標準入力に送ります。
    4.  シェルの標準出力からのデータは`node-pty`プロセスの`data`イベントで捕捉し、そのままWebSocket経由でクライアントに送信します。
    5.  クライアントが切断した際には、対応する`node-pty`プロセスを確実に`kill`し、ゾンビプロセスが残らないようにします。

#### **セキュリティ関連処理**

-   **アクセスログの記録:**
    -   **概要:** 認証APIへのすべてのリクエストを、PostgreSQLの`audit_logs`テーブルに記録します。これにより、ファイルベースのログよりも高度な検索や集計が可能になります。
    -   **実装:** 認証処理を行うAPIエンドポイントまたはミドルウェア内で、PrismaやTypeORMなどのORM（Object-Relational Mapper）を通じて`audit_logs`テーブルにレコードをINSERTします。IPアドレスから国を推定するには`geoip-lite`などのライブラリを利用し、得られた国コードを`country_code`カラムに保存します。

-   **ファイアウォール操作:**
    -   **概要:** フロントエンドからの要求に応じて`ufw`コマンドを実行し、その結果を`firewall_blocks`テーブルと同期させます。
    -   **実装:**
        1.  フロントエンドからブロック要求（IPアドレス、メモ）が来ると、まず`firewall_blocks`テーブルに新しいレコードをINSERT（または更新）します。
        2.  DBへの書き込みが成功した後、`child_process`で`ufw deny from <IP>`コマンドを実行します。
        3.  コマンドの実行に失敗した場合は、DBの変更をロールバック（元に戻す）し、フロントエンドにエラーを返します。これにより、DBの状態と実際のファイアウォールの状態の乖離を防ぎます。
        4.  **権限管理:** `sudo`権限が必要なため、`visudo`コマンドで設定ファイルを編集し、Node.jsの実行ユーザーにパスワードなしで特定の`ufw`コマンドのみを実行できるよう、厳格な権限設定を行います。（例: `nodeuser ALL=(ALL) NOPASSWD: /usr/sbin/ufw deny *, /usr/sbin/ufw delete deny *`）

-   **パッケージ更新情報の取得:**
    -   **概要:** 指定されたホスト/コンテナに対して`apt`関連のコマンドを実行し、その出力を解析してフロントエンドに返します。
    -   **実装:**
        -   Proxmoxホストに対しては、直接`apt list --upgradable`を実行します。
        -   LXCコンテナに対しては、`pct exec <コンテナID> -- apt list --upgradable`のように、`pct exec`コマンド経由でコンテナ内部のコマンドを実行します。
        -   コマンドの標準出力を正規表現などでパースし、パッケージ名、バージョン、そして`[security]`という文字列が含まれているかどうかを判定し、セキュリティアップデートのフラグを立ててからJSON形式でフロントエンドに返します。

---

### 5. データベース (PostgreSQL)

-   **DB名:** `admin_db`
-   **ユーザー名:** `admin_user`
-   **スキーマ設計:**

##### **`audit_logs` テーブル**

-   **概要**:
    管理者サイトへのすべてのログイン試行（成功・失敗問わず）を記録するためのテーブルです。「セキュリティ」ページの「アクセスログ」タブのデータソースとなります。

-   **カラム定義**:
    -   `id`
        -   **データ型**: `SERIAL`
        -   **制約**: `PRIMARY KEY`
        -   **説明**: ログの一意な連番ID。
    -   `timestamp`
        -   **データ型**: `TIMESTAMP WITH TIME ZONE`
        -   **制約**: `NOT NULL`, `DEFAULT CURRENT_TIMESTAMP`
        -   **説明**: イベントが発生した日時。
    -   `auth_type`
        -   **データ型**: `VARCHAR(20)`
        -   **制約**: `NOT NULL`
        -   **説明**: 試行された認証の種類（例: `'GOOGLE'`, `'PASSWORD'`）。
    -   `outcome`
        -   **データ型**: `VARCHAR(10)`
        -   **制約**: `NOT NULL`
        -   **説明**: 認証試行の結果（`'SUCCESS'`, `'FAILURE'`）。
    -   `email`
        -   **データ型**: `VARCHAR(255)`
        -   **制約**: `NULL`許容
        -   **説明**: Google認証で試行されたメールアドレス。
    -   `ip_address`
        -   **データ型**: `VARCHAR(45)`
        -   **制約**: `NOT NULL`
        -   **説明**: リクエスト元のIPアドレス。IPv6にも対応。
    -   `country_code`
        -   **データ型**: `VARCHAR(2)`
        -   **制約**: `NULL`許容
        -   **説明**: IPアドレスから推定された国を示す2文字のコード（例: `JP`, `US`）。
    -   `user_agent`
        -   **データ型**: `TEXT`
        -   **制約**: `NULL`許容
        -   **説明**: リクエスト元のブラウザやクライアント情報。

-   **インデックス**:
    -   `timestamp`: 時系列での検索やソートを高速化します。
    -   `ip_address`: 特定のIPアドレスからのアクセス履歴を高速に検索するために設定します。

##### **`firewall_blocks` テーブル**

-   **概要**:
    UFW (Uncomplicated Firewall) によってブロックされたIPアドレスの情報を永続的に管理します。「セキュリティ」ページの「ファイアウォール」タブで表示・操作するリストの元データとなります。`ufw status`コマンドの出力を都度パースするよりも、信頼性が高く、追加情報（理由など）も管理できます。

-   **カラム定義**:
    -   `id`
        -   **データ型**: `SERIAL`
        -   **制約**: `PRIMARY KEY`
        -   **説明**: ブロック情報の一意な連番ID。
    -   `ip_address`
        -   **データ型**: `VARCHAR(45)`
        -   **制約**: `NOT NULL`, `UNIQUE`
        -   **説明**: ブロック対象のIPアドレス。重複してブロックしないように`UNIQUE`制約を設けます。
    -   `is_active`
        -   **データ型**: `BOOLEAN`
        -   **制約**: `NOT NULL`, `DEFAULT true`
        -   **説明**: このブロックルールが現在有効かどうかを示すフラグ。`true`なら有効（ブロック中）、`false`なら無効（ブロック解除済み）。レコードを削除せずに履歴として残せます。
    -   `memo`
        -   **データ型**: `TEXT`
        -   **制約**: `NULL`許容
        -   **説明**: なぜこのIPをブロックしたかの理由を記録するメモ欄（例: `ログイン試行に5回失敗`, `管理者による手動ブロック`）。
    -   `blocked_at`
        -   **データ型**: `TIMESTAMP WITH TIME ZONE`
        -   **制約**: `NOT NULL`, `DEFAULT CURRENT_TIMESTAMP`
        -   **説明**: IPアドレスがブロックされた日時。
    -   `unblocked_at`
        -   **データ型**: `TIMESTAMP WITH TIME ZONE`
        -   **制約**: `NULL`許容
        -   **説明**: ブロックが解除された日時。`is_active`が`false`になった時に記録します。

-   **インデックス**:
    -   `ip_address`: `UNIQUE`制約により自動で作成されます。IPアドレスによる検索を高速化します。
    -   `is_active`: 現在ブロック中のIPアドレス（`WHERE is_active = true`）を高速に一覧表示するために設定します。