-   **URLパス:** `/protube/`
-   **フォルダ:** `srv/youtube-proxy/`
-   **コンセプト:** 自作サーバーを**完全なプロキシ**として介し、**ショート動画・ライブ配信を含むYouTubeとほぼ同等のUI/UXを提供する**高機能なWebクライアント。広告やトラッキングを排除し、独自の永続的なお気に入り・履歴機能を追加価値として提供する。
-   **構成:** **分離型 (Frontend: Next.js + Backend: Express.js)**

---

### 1. フロントエンド (Next.js)

-   **役割:** UIのレンダリングとユーザーインタラクションに特化する「シンクライアント」。YouTubeとの通信ロジックは一切持たず、すべてのデータを自作バックエンド経由で取得する。これにより、フロントエンドは表示ロジックに集中でき、バックエンドはデータ取得とビジネスロジックに責任を持つという明確な責務分離を実現する。
-   **パフォーマンス戦略:**
    -   **SSR (サーバーサイドレンダリング):** トップページや動画再生ページなど、初期表示が重要なページはSSRを採用。Next.jsサーバーがページ描画に必要なデータをバックエンドAPIから取得し、完全にレンダリングされたHTMLをクライアントに返すことで、体感表示速度を向上させ、SEOにも有利な構造とする。
    -   **SSRキャッシュ (Redis活用):** 一度SSRで生成したページのHTMLをRedisにキャッシュする。同一ページへの後続リクエストは、APIコールや再レンダリングをスキップし、Redisから直接HTMLを返すことで、サーバー負荷を大幅に軽減し、超高速なレスポンスを実現する。詳細は「5. Redisキャッシュ戦略」で後述。

-   **UI/UX - YouTubeの模倣:**
    -   **レイアウト:**
        -   **ヘッダー:** ロゴ、サジェスト機能付き検索バー、ユーザーアイコン（ログイン状態を表示）を配置。
        -   **サイドバー（開閉式）:** トップ、ショート、急上昇などのナビゲーション。ログイン時にはお気に入り、履歴へのリンクも表示。
        -   **メインコンテンツエリア:** 動画グリッド、またはページに応じた専用レイアウト。
    -   **ページごとの詳細な挙動:**
        -   **トップページ (`/protube/`):**
            -   **実装:** 無限スクロールを`react-intersection-observer`ライブラリを用いて実装。ユーザーがページ下部に到達すると、バックエンドに次のページのデータを要求する。
            -   **UI:** 通常動画のおすすめグリッドに加え、「ショート」セクションを横スクロール可能なカルーセル形式で表示し、多様なコンテンツへの導線を確保する。
            -   **インタラクション:** 動画サムネイルにマウスオーバーすると、ミュート状態で動画のプレビューが再生される。
        -   **検索結果ページ (`/protube/results?search_query=...`):**
            -   **UI:** 通常動画、ショート動画、ライブ配信、チャンネル、再生リストなどを混在させてリスト表示。それぞれに専用のバッジやアイコンを付け、視覚的に種類を判別しやすくする。
            -   **機能:** タイプ（動画、チャンネル等）、アップロード日、長さなどによるフィルタリング機能を実装。
        -   **通常動画再生ページ (`/protube/watch?v=...`):**
            -   **プレイヤー:** `react-player`ライブラリを活用し、再生速度変更、画質選択、シアターモード、ピクチャーインピクチャーなど、多機能なレスポンシブプレイヤーを実装。
            -   **動画下部:** タイトル、チャンネル情報、高評価数、再生回数、概要欄（開閉式）、そしてProTube独自のお気に入りボタンを配置。
            -   **右側サイド:** 「関連動画」のリストを表示。自動再生のオン/オフ機能も提供。
            -   **コメント欄:** 関連動画リストの下に配置し、返信の表示にも対応。
        -   **ショート動画再生ページ (`/protube/shorts/:id`):**
            -   **レイアウト:** スマートフォンでの視聴体験を最適化するため、縦型全画面表示の専用UIを採用。
            -   **操作:** 上下スクロール/スワイプで次々と動画を切り替えられる、中毒性の高いインターフェースを再現。
            -   **UI:** プレイヤー上にお気に入りボタンやチャンネル情報などの各種操作アイコンをオーバーレイ表示。
        -   **ライブ配信再生ページ (`/protube/watch?v=...` & `isLive=true`):**
            -   **プレイヤー:** 低遅延再生モードに対応し、リアルタイム性を重視。
            -   **ライブチャット:** プレイヤーの右側に、リアルタイムで更新されるチャット欄を表示。
            -   **配信ステータス:** 「ライブ配信中」のインジケーターと現在の視聴者数を表示。
    -   **共通インタラクション:**
        -   **ミニプレイヤー:** `zustand`などのグローバル状態管理ライブラリを使用し、動画を再生しながら別ページに遷移しても、画面右下に小さなプレイヤーで再生を継続できるようにする。
        -   **キーボードショートカット:** `J` `K` `L`キーでのシーク、`M`キーでのミュートなど、YouTubeの標準的なショートカットを実装。
        -   **ローディングスケルトン:** データ取得中にコンテンツのワイヤーフレームを表示することで、ユーザーの体感待機時間を短縮する。

---

### 2. バックエンド (Express.js)

-   **役割:** このアプリケーションの**頭脳であり心臓部**。単なる中継役ではなく、フロントエンドからのリクエストを安全に処理し、ビジネスロジックを実行し、外部(YouTube)と内部(DB, Redis)のデータソースを適切に統合して、フロントエンドが最も使いやすい形でデータを提供する責務を負う。
-   **ポート (PM2):** `3001`
-   **アーキテクチャ (役割ベース):**
    -   **ルーティング層 (`routes/`):** APIのエンドポイント定義に特化。`POST /api/v1/auth/login` のようなURLパスと、それに対応するコントローラーのメソッドを紐付ける。リクエストボディやクエリパラメータのバリデーション（`express-validator`を使用）もこの層で行い、不正なリクエストを早期に弾く。
    -   **コントローラー層 (`controllers/`):** ルーティング層から受け取ったリクエストを解釈し、適切なサービスクラスのメソッドを呼び出す「交通整理役」。HTTPリクエストとレスポンスに直接関わるが、複雑なビジネスロジックは含まず、サービス層からの結果をクライアントに適した形式（JSON）に整形して返す責務を持つ。
    -   **サービス層 (`services/`):** アプリケーションの主要なビジネスロジックを実装する「実務部隊」。
        -   `youtube.service.js`: `youtubei.js`ライブラリをラップし、YouTubeからのデータ取得と、フロントエンドで使いやすい形へのデータ整形ロジックをカプセル化する。Redisキャッシュ層との連携（キャッシュの確認、保存）もこのサービスが担当する。
        -   `auth.service.js`: ユーザー登録時のパスワードハッシュ化、ログイン時のパスワード検証、JWT（JSON Web Token）の生成・検証など、認証に関するすべてのロジックを実装する。
        -   `user.service.js`: お気に入りや視聴履歴のデータベースへの保存・取得・削除など、ユーザー固有の機能に関するビジネスロジックを実装する。
    -   **ミドルウェア層 (`middleware/`):** リクエスト処理フローに介在し、横断的な関心事を処理する。
        -   `auth.middleware.js`: 保護されたエンドポイントへのリクエストに対し、HTTPヘッダーやCookieからJWTを検証する。検証に成功した場合、ユーザー情報をリクエストオブジェクトに付与し、後続のコントローラーやサービスが利用できるようにする。
        -   `error.handler.js`: アプリケーション全体で発生したエラーを一元的に捕捉し、開発環境では詳細なスタックトレースを、本番環境では汎用的なエラーメッセージを返すなど、環境に応じた統一形式のエラーレスポンスを生成する。
-   **セキュリティ:**
    -   `helmet`: XSS保護、Content-Security-Policyなど、セキュリティ関連のHTTPヘッダーを適切に設定し、一般的なWebの脆弱性からアプリケーションを保護する。
    -   `cors`: フロントエンドのオリジン（Next.jsサーバーのURL）からのみリクエストを許可するよう設定し、意図しないドメインからのAPIアクセスをブロックする。
    -   `express-rate-limit`: ログイン試行APIなど、ブルートフォース攻撃の対象となりうるエンドポイントに対し、同一IPからのリクエスト回数を制限する。

---

### 3. API設計

#### **認証 (Auth)**
-   **Endpoint**: `/api/v1/auth/*`
    -   **概要**: ユーザーの新規登録、ログイン、ログアウト、セッション状態の確認など、認証に関するすべての処理を担う。
    -   **エンドポイント群**:
        -   `POST /register`: 新規ユーザーを登録する。
        -   `POST /login`: ログイン処理。成功時に、HTTPOnly属性を付けたセキュアなCookieにJWTをセットして返す。
        -   `POST /logout`: ログアウト処理。サーバー側でCookieをクリアする。
        -   `GET /me`: 現在のログインユーザー情報（ID、ユーザー名など）を返す。フロントエンドがページの表示を切り替えるために使用する。
    -   **アクセス権限**: `GUEST` (一部), `USER` (一部)

#### **公開情報 (YouTube Proxy)**
フロントエンドが必要とするYouTubeのデータをプロキシするAPI群。認証は不要。

-   **Endpoint**: `GET /api/v1/youtube/home`
    -   **概要**: トップページに表示するための、おすすめ動画やショート動画のフィードを取得する。
    -   **アクセス権限**: `GUEST` (全ユーザー)

-   **Endpoint**: `GET /api/v1/youtube/search`
    -   **概要**: キーワードに基づいて検索結果を取得する。
    -   **アクセス権限**: `GUEST` (全ユーザー)
    -   **クエリパラメータ**: `q` (検索語), `filter` (フィルタ条件)

-   **Endpoint**: `GET /api/v1/youtube/video/:id`
    -   **概要**: 動画再生ページに必要なすべての情報（動画メタデータ、ストリームURL、関連動画、コメント等）を一度のAPIコールでまとめて取得する。これにより、フロントエンドのレンダリングパフォーマンスを向上させる。
    -   **アクセス権限**: `GUEST` (全ユーザー)

-   **Endpoint**: `GET /api/v1/youtube/shorts`
    -   **概要**: ショート動画プレイヤー用のフィードを連続で取得する。
    -   **アクセス権限**: `GUEST` (全ユーザー)

-   **Endpoint**: `POST /api/v1/youtube/live_chat`
    -   **概要**: ライブ配信のチャットメッセージを継続的に取得するためのエンドポイント。
    -   **アクセス権限**: `GUEST` (全ユーザー)

#### **ユーザー専用機能 (User Actions)**
ログインしているユーザーのみが利用できる、パーソナライズされた機能のAPI群。すべて認証ミドルウェアによって保護される。

-   **Endpoint**: `GET, POST /api/v1/user/history`
    -   `GET`: 自身の視聴履歴をページネーション付きで一覧取得する。
    -   `POST`: 新しい視聴履歴をデータベースに追加する。
    -   **アクセス権限**: `USER` (要認証)

-   **Endpoint**: `GET, POST /api/v1/user/favorites`, `DELETE /api/v1/user/favorites/:videoId`
    -   `GET`: 自身のお気に入り動画リストを一覧取得する。
    -   `POST`: 新しいお気に入り動画をデータベースに追加する。
    -   `DELETE`: 指定した動画をお気に入りから削除する。
    -   **アクセス権限**: `USER` (要認証)

---

### 4. データベース (PostgreSQL)

-   **DB名:** `protube_db`
-   **ユーザー名:** `protube_user`
-   **スキーマ設計:**

    -   **`users` テーブル**
        -   **概要**: サイトに登録したユーザーの認証情報を管理する。個人情報は最小限に留める。
        -   **カラム定義**:
            -   `id`: `SERIAL PRIMARY KEY` - ユーザーの一意な連番ID。
            -   `username`: `VARCHAR(50) NOT NULL UNIQUE` - ユーザー名。
            -   `email`: `VARCHAR(255) NOT NULL UNIQUE` - ログインや通知に使用するメールアドレス。
            -   `password_hash`: `VARCHAR(255) NOT NULL` - `bcrypt`などでハッシュ化されたパスワード。
            -   `created_at`: `TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP` - 登録日時。
        -   **インデックス**: `email`, `username` (ログイン時の検索パフォーマンス向上のため)。

    -   **`watch_history` テーブル**
        -   **概要**: 全ユーザーの視聴履歴を記録する。
        -   **カラム定義**:
            -   `id`: `SERIAL PRIMARY KEY` - 履歴レコードの一意なID。
            -   `user_id`: `INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE` - どのユーザーの履歴かを示す外部キー。ユーザーが退会(`DELETE`)した場合、関連する履歴も自動的に削除(`CASCADE`)される。
            -   `video_id`: `VARCHAR(50) NOT NULL` - YouTubeの動画ID。
            -   `video_type`: `VARCHAR(10) NOT NULL` - 動画の種類 (`NORMAL`, `SHORT`, `LIVE`)。
            -   `video_title`: `VARCHAR(255)` - 表示高速化のための非正規化データ。履歴一覧表示時に都度APIを叩く必要がなくなる。
            -   `channel_name`: `VARCHAR(255)` - 表示高速化のための非正規化データ。
            -   `watched_at`: `TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP` - 視聴日時。
        -   **インデックス**: `(user_id, watched_at DESC)` (特定のユーザーの履歴を新しい順に高速で取得するため)。

    -   **`favorites` テーブル**
        -   **概要**: 全ユーザーのお気に入り動画を管理する。
        -   **カラム定義**:
            -   `id`: `SERIAL PRIMARY KEY` - お気に入りレコードの一意なID。
            -   `user_id`: `INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE` - どのユーザーのお気に入りかを示す外部キー。
            -   `video_id`: `VARCHAR(50) NOT NULL` - YouTubeの動画ID。
            -   `video_type`: `VARCHAR(10) NOT NULL` - 動画の種類 (`NORMAL`, `SHORT`, `LIVE`)。
            -   `video_title`: `VARCHAR(255)` - 表示高速化のための非正規化データ。
            -   `channel_name`: `VARCHAR(255)` - 表示高速化のための非正規化データ。
            -   `added_at`: `TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP` - お気に入りに追加した日時。
        -   **制約**: `UNIQUE (user_id, video_id)` - 同一ユーザーが同じ動画を複数お気に入り登録できないようにするための複合ユニーク制約。
        -   **インデックス**: `user_id` (特定ユーザーのお気に入り一覧を高速で取得するため)。

---

### 5. Redisキャッシュ戦略

-   **目的:** アプリケーション全体のパフォーマンスを劇的に向上させるため、揮発性データを高速に読み書きできるインメモリデータベースRedisを多層的に活用する。
-   **役割:**
    1.  **APIレスポンスキャッシュ:** バックエンド(Express.js)がYouTubeへ問い合わせる回数を削減し、APIの応答速度を向上させ、レートリミットのリスクを低減する。
    2.  **SSRページキャッシュ:** フロントエンド(Next.js)がページを再レンダリングする回数を削減し、サーバー負荷を軽減し、ユーザーへのレスポンスを最速化する。
    3.  **セッション管理 (将来的な拡張):** ユーザーセッション情報を格納し、ステートレスな認証基盤を支える。

-   **実装詳細:**
    -   **APIレスポンスキャッシュ (バックエンド側):**
        -   **対象:** `GET /api/v1/youtube/*` のうち、結果が頻繁に変動しないエンドポイント。
        -   **フロー:**
            1.  コントローラーがリクエストを受け取ると、`youtube.service.js`はまずリクエストURLやクエリパラメータから一意なキャッシュキーを生成する (例: `api:search:q=Next.js&filter=video`)。
            2.  そのキーでRedisにデータが存在するか確認する。
            3.  **キャッシュヒット:** RedisからJSON文字列を取得し、パースして即座にクライアントに返す。YouTubeへの通信は一切発生しない。
            4.  **キャッシュミス:** `youtubei.js`を呼び出してYouTubeからデータを取得。取得したデータをクライアントに返しつつ、**非同期で**取得データをJSON文字列化してRedisに保存する（TTLを設定）。
        -   **TTL (Time To Live - 有効期限) の設定:**
            -   `GET /home`: **15分** (おすすめは比較的頻繁に変わるため)
            -   `GET /search`: **1時間** (同じキーワードの検索結果はしばらく変わらない)
            -   `GET /video/:id` (通常動画): **6時間** (動画メタデータはほぼ不変)
            -   `GET /video/:id` (ライブ配信): **キャッシュしない** (リアルタイム性が最重要のため)
    -   **SSRページキャッシュ (フロントエンド側):**
        -   **対象:** トップページや動画再生ページなど、SSRで生成されるが、全ユーザーで共通して見れる公開ページ。
        -   **フロー:**
            1.  Next.jsのサーバーサイド（`getServerSideProps`など）でページのリクエストを受け取る。
            2.  まずリクエストURLから一意なキャッシュキーを生成する (例: `page:/protube/watch?v=...`)。
            3.  RedisにそのキーでキャッシュされたHTMLが存在するか確認する。
            4.  **キャッシュヒット:** RedisからHTML文字列を直接取得し、クライアントに返す。**この場合、バックエンドAPIへの問い合わせやReactのレンダリング処理は一切発生しない。**
            5.  **キャッシュミス:** 通常通りバックエンドAPIからデータを取得し、ReactコンポーネントをレンダリングしてHTMLを生成。生成したHTMLをクライアントに返しつつ、**非同期で**RedisにHTMLを保存する（TTLを設定）。
        -   **TTLの設定:**
            -   トップページ: **5分**
            -   動画再生ページ: **30分**
    -   **キャッシュの無効化 (パージ):**
        -   初期実装ではTTLによる自動失効を基本とする。将来的には、YouTube側で動画が削除された場合などに、Webhookなどを利用して能動的に関連キャッシュを削除するロジックも検討可能。